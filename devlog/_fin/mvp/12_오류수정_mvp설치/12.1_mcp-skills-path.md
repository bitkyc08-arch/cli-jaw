# Phase 12.1: MCP/Skills 경로 통합 설계

> cli-claw가 spawn하는 CLI에 MCP 서버를 제공하고, 스킬 경로를 일관되게 관리하는 설계

---

## 1. 현재 문제

### 1.1 MCP: spawn된 CLI가 MCP 서버를 못 찾음

```
cli-claw → spawn(cli, args, { cwd: settings.workingDir })
         → CLI가 cwd 기준으로 MCP config 탐색
         → workingDir ≠ 프로젝트 루트면 → MCP 서버 0개
```

현재 `settings.workingDir = "/Users/jun"` (홈) → `.mcp.json`은 `/Users/jun/Developer/new/.mcp.json`에 있음 → **불일치**.

### 1.2 Skills: workingDir 기반 스킬 탐색 불일치

```
postinstall: ~/.agents/skills → ~/.cli-claw/skills  (홈 고정)
CLI 탐색:    {cwd}/.agents/skills                    (cwd 기반)
```

workingDir가 홈이 아니면 `.agents/skills` symlink 미발견.

---

## 2. CLI별 MCP Config 포맷 비교

### 2.1 실제 포맷 (확인됨)

| CLI         | 파일 위치                          | 포맷 | 키 구조                | 발견 우선순위                             |
| ----------- | ---------------------------------- | ---- | ---------------------- | ----------------------------------------- |
| Claude Code | `{cwd}/.mcp.json`                  | JSON | `mcpServers.{name}`    | project → global(`~/.mcp.json`)           |
| Codex       | `~/.codex/config.toml`             | TOML | `[mcp_servers.{name}]` | global → project(`.codex/config.toml`)    |
| Gemini CLI  | `~/.gemini/settings.json`          | JSON | `mcpServers.{name}`    | global → project(`.gemini/settings.json`) |
| OpenCode    | `~/.config/opencode/opencode.json` | JSON | `mcp.{name}`           | global → project(`opencode.json`)         |

### 2.2 Key 매핑 테이블

```
통합 키          Claude/Gemini        Codex              OpenCode
───────────────  ──────────────────   ─────────────────  ──────────────────
name             mcpServers.{name}    [mcp_servers.name] mcp.{name}
command          command: "npx"       command = "npx"    command: ["npx", "-y", "..."]
args             args: ["-y", "..."]  args = [...]       (command 배열에 통합)
env              env: { K: "V" }      [mcp_servers.name.env] environment: { K: "V" }
                                      K = "V"
type             (없음, 기본 stdio)   (없음)             type: "local" | "remote"
url              (없음)               url = "..."        url: "..." (type: remote)
```

### 2.3 핵심 차이점

1. **Codex**: TOML 포맷, `mcp_servers` (underscore), env는 별도 `[mcp_servers.name.env]` 섹션
2. **OpenCode**: `command`가 **배열** (command + args 통합), env 키가 `environment`
3. **Claude/Gemini**: 포맷 거의 동일 (JSON, `mcpServers`, `command`+`args`+`env`)
4. **Codex**: `features.rmcp_client = true` 필요 (MCP 활성화 플래그)

---

## 3. 설계: 통합 MCP Config + CLI별 변환

### 3.1 통합 포맷 (Source of Truth)

`~/.cli-claw/mcp.json`에 CLI-agnostic 통합 포맷 저장:

```json
{
    "servers": {
        "context7": {
            "command": "npx",
            "args": ["-y", "@upstash/context7-mcp"],
            "env": {}
        },
        "markdown-rag": {
            "command": "uv",
            "args": ["--directory", "/path/to/mcp", "run", "server.py"],
            "env": {
                "MILVUS_ADDRESS": "http://100.76.170.81:19530",
                "GOOGLE_APPLICATION_CREDENTIALS": "/Users/jun/secure/vertex-sa.json"
            }
        }
    }
}
```

### 3.2 변환 모듈: `lib/mcp-sync.js`

```js
export function toClaudeMcp(config) {
    // → { mcpServers: { name: { command, args, env } } }
    const mcpServers = {};
    for (const [name, srv] of Object.entries(config.servers)) {
        mcpServers[name] = { command: srv.command, args: srv.args || [] };
        if (srv.env && Object.keys(srv.env).length) mcpServers[name].env = srv.env;
    }
    return JSON.stringify({ mcpServers }, null, 4);
}

export function toCodexToml(config) {
    // → [mcp_servers.name]\ncommand = "..."\nargs = [...]\n[mcp_servers.name.env]\nK = "V"
    let toml = '';
    for (const [name, srv] of Object.entries(config.servers)) {
        toml += `[mcp_servers.${name}]\n`;
        toml += `command = "${srv.command}"\n`;
        toml += `args = ${JSON.stringify(srv.args || [])}\n`;
        if (srv.env && Object.keys(srv.env).length) {
            toml += `[mcp_servers.${name}.env]\n`;
            for (const [k, v] of Object.entries(srv.env)) {
                toml += `${k} = "${v}"\n`;
            }
        }
        toml += '\n';
    }
    return toml;
}

export function toGeminiSettings(config) {
    // → mcpServers 블록 (Claude와 동일 구조)
    return toClaudeMcp(config);  // 포맷 동일
}

export function toOpenCode(config) {
    // → { mcp: { name: { type: "local", command: ["cmd", ...args], environment: {...} } } }
    const mcp = {};
    for (const [name, srv] of Object.entries(config.servers)) {
        mcp[name] = {
            type: 'local',
            command: [srv.command, ...(srv.args || [])],
        };
        if (srv.env && Object.keys(srv.env).length) mcp[name].environment = srv.env;
    }
    return JSON.stringify({ mcp }, null, 4);
}
```

### 3.3 동기화 전략

```
1. cli-claw init / postinstall 시
   → ~/.cli-claw/mcp.json 없으면 기본 템플릿 생성
   → 기존 .mcp.json 발견하면 import

2. /mcp 명령 (Web UI 또는 CLI chat)
   → ~/.cli-claw/mcp.json 편집
   → 저장 시 자동으로 4개 타겟에 동기화:
     a) {workingDir}/.mcp.json          (Claude Code)
     b) ~/.codex/config.toml            (Codex — MCP 섹션만 교체)
     c) ~/.gemini/settings.json         (Gemini — mcpServers 블록만 교체)
     d) ~/.config/opencode/opencode.json (OpenCode — mcp 블록만 교체)

3. 서버 시작 시 (server.js)
   → workingDir에 .mcp.json 없으면 자동 생성
```

### 3.4 Codex TOML 부분 교체 전략

config.toml에는 MCP 외에 model, personality 등 다른 설정도 있음.
**MCP 섹션만 교체**하는 방법:

```js
function patchCodexToml(existingToml, newMcpToml) {
    // 1. [mcp_servers.*] 로 시작하는 모든 줄 제거
    // 2. newMcpToml 추가
    const lines = existingToml.split('\n');
    const filtered = [];
    let inMcp = false;
    for (const line of lines) {
        if (line.match(/^\[mcp_servers\./)) { inMcp = true; continue; }
        if (inMcp && line.match(/^\[/) && !line.match(/^\[mcp_servers\./)) { inMcp = false; }
        if (!inMcp) filtered.push(line);
    }
    return filtered.join('\n') + '\n' + newMcpToml;
}
```

---

## 4. Skills 경로 전략

### 4.1 init 시 symlink 생성

```js
// postinstall.js 또는 server 시작 시
function ensureSkillsSymlink(workingDir) {
    const target = path.join(os.homedir(), '.cli-claw', 'skills');
    const link = path.join(workingDir, '.agents', 'skills');
    
    if (fs.existsSync(link)) return;  // 이미 존재 (실제 dir이든 symlink이든)
    fs.mkdirSync(path.dirname(link), { recursive: true });
    fs.symlinkSync(target, link);
}
```

### 4.2 Symlink 체인

```
~/.cli-claw/skills/              ← 물리 디렉토리 (실제 스킬 파일)
~/.agents/skills → ~/.cli-claw/skills/        ← postinstall (홈 기본)
{workingDir}/.agents/skills → ~/.cli-claw/skills/  ← init (workingDir)
```

- 어느 링크에 스킬을 넣어도 같은 물리 디렉토리로 귀결
- CLI가 cwd 기준 `.agents/skills` 탐색하면 항상 발견
- workingDir가 홈이면 중복 symlink이지만 무해 (skip)

### 4.3 프롬프트 안내

system prompt에 추가:
```
스킬은 .agents/skills/ 디렉토리에 저장됩니다.
새 스킬: .agents/skills/{name}/SKILL.md 생성.
```

---

## 5. 구현 파일 목록

| 파일                   | 변경                                                  |
| ---------------------- | ----------------------------------------------------- |
| `lib/mcp-sync.js`      | **[NEW]** 통합→CLI별 변환 (4개 함수) + patchCodexToml |
| `bin/postinstall.js`   | workingDir 기반 skills symlink + mcp.json 생성        |
| `server.js`            | 서버시작 시 `ensureMcpConfig(workingDir)` 호출        |
| `server.js`            | `POST /api/mcp` 엔드포인트 (Web UI에서 MCP 편집)      |
| `public/index.html`    | Settings 탭에 MCP 에디터 (서버 추가/삭제/동기화)      |
| `bin/commands/chat.js` | `/mcp` 명령 (현재 MCP 서버 조회 + 동기화 트리거)      |

## 6. 구현 순서

- [ ] 12.1.1 `lib/mcp-sync.js` 변환 모듈
- [ ] 12.1.2 `bin/postinstall.js` skills symlink + mcp.json 초기화
- [ ] 12.1.3 `server.js` 서버시작 시 MCP 보장
- [ ] 12.1.4 `POST /api/mcp` + Web UI MCP 에디터
- [ ] 12.1.5 `/mcp` CLI 명령
- [ ] 12.1.6 테스트 (workingDir 변경 → MCP 동기화 확인)
